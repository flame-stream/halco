\section{Идея}

Вершины вычислительных графов могут быть двух типов: \textbf{источники} и операции (\textbf{трансформации}). Источники не получают данных, только отдают. Операции принимают один или несколько потоков данных и могут порождать поток данных, а так же могут формировать результаты работы графа (в виде записи в базе данных, нового потока для другой системы, и т.д.).

Будем называть \textbf{нодами} вершины обоих типов.

Чтобы иметь возможность изменять форму графа, для каждой операции необходимо иметь информацию о требованиях, которые она выдвигает к данным, поступающим на её вход, и гарантии, которые она выставляет для производимых ею данных.

Такие требования и гарантии назовём \textbf{контрактами} операции, \textbf{входными} и \textbf{выходными} соответственно.

Далее будут приводиться листинги на языке Haskell, формализующие вводимые понятия.

\begin{lstlisting}
    -- InCont - входной контракт.
    -- OutCont - выходной контракт.
    -- Пока предположим, что трансформаций арности два будет достаточно.

    -- Вершины вычислительного графа, аннотированные контрактами
    data Node =
        Stream OutCont             -- Источник данных.
      | Tfm1 InCont OutCont        -- Трансформация арности один.
      | Tfm2 InCont InCont OutCont -- Трансформация арности два.
\end{lstlisting}

Зададим множество нод, аннотированных контрактами (\textbf{окружение}):
\begin{lstlisting}
    type Env = Map NodeName Node
\end{lstlisting}

Определим \textbf{семантику} вычислительного графа как подмножество множества нод, элементы которого формируют требуемые от графа результаты работы:
\begin{lstlisting}
    type Semantics = Set NodeName
\end{lstlisting}

Наконец, определим \textbf{ц-граф}, который перставляет собой пару из окружения и семантики:
\begin{lstlisting}
    type CGraph = (Env, Semantics)
\end{lstlisting}

Пусть ц-граф задаёт множество \textbf{конкретных графов} (или просто \textbf{графов}) следующим образом:
граф задаётся данным ц-графом, если он состоит только из нод окружения, содержит каждую ноду семантики один раз, и контракты всех используемых нод удовлетворяются.

Будем использовать ц-графы в качестве нового способа задания вычислительных графов.
Каждый конкретный граф содержит ноды, формирующие требуемый результат работы.
Все ноды каждого графа получают валидные данные на вход и, следовательно, работают корректно.
Таким образом, все операции семантики так же работают корректно, и каждый граф, соответствующий данному ц-графу, выполняет одну и ту же, требуемую, работу.

Процесс от задания ц-графа до запуска задачи на целевом фреймворке выглядит следующим образом:
\begin{lstlisting}
    -- [Graph] - список графов.
    -- Точка - оператор композиции функций.

    -- RGraph - конкретный граф в API целевого фреймворка.
    run :: CGraph -> Runtime RGraph
    run = graphToRGraph    -- Преобразовать конкретный граф в
                           -- вычислительный граф целевого фреймворка.
        . chooseGraph cost -- Выбрать оптимальный граф в соответствии
                           -- с функцией оценки cost.
        . genGraphs        -- Сгенерировать все графы, соответствующие
                           -- данному CGraph.

    genGraphs :: CGraph -> [Graph]
    cost :: Graph -> Integer
    chooseGraph :: (Graph -> Integer) -> [Graph] -> Graph
    graphToRGraph :: Graph -> Runtime RGraph
\end{lstlisting}


\subsection{Конкретные графы}

Будем представлять граф виде множества термов. Результат работы одной ноды может подаваться на вход нескольким нодам, поэтому в операциях будем хранить не сами подтермы, а их идентификаторы.

\begin{lstlisting}
    data Term =
        Const NodeName
      | App1 NodeName TermId
      | App2 NodeName TermId TermId

    type Graph = Map TermId Term
\end{lstlisting}


\subsection{Контракты}

Будем считать, что данные имеют формат записей с именованными атрибутами.
Тогда существует два сорта информации о потоке данных: какие атрибуты имеют записи и какие существуют свойства атрибутов и связей между ними.

Введём состояние потока как совокупность информации о нём:
\begin{lstlisting}
    -- Атрибуты
    type Attr = AttrName

    -- Свойства
    type Prop = PropName

    data State = State
      { attrs :: Set Attr -- Множество атрибутов в потоке.
      , props :: Set Prop -- Множество свойств в потоке.
      }
\end{lstlisting}

Введём входной контракт и правило проверки:
\begin{lstlisting}
    data InCont = InCont
      { attrsI  :: Set Attr -- Множество требуемых атрибутов.
      , propsI  :: Set Prop -- Множество требуемых свойств.
      , propsI' :: Set Prop -- Множество запрещённых свойств.
      }

    match :: State -> InCont -> Bool
    match s c = attrsI c `Set.isSubsetOf` attrs s
             && propsI c `Set.isSubsetOf` props s
             && propsI' c `Set.disjoint`  props s
\end{lstlisting}

Пусть выходной контракт определяет разницу между состояниями входного и выходного потоков. Введём выходной контракт и правило обновления состояния:

\begin{lstlisting}
    data OutAttrs =
        AddAttrs (Set Attr) -- К множеству входящих атрибутов
                            -- добавятся новые из множества.
      | NewAttrs (Set Attr) -- Множество входящих атрибутов
                            -- заменится на новое.

    data OutCont = OutCont
      { attrsO  :: OutAttrs -- Изменения в составе атрибутов
                            -- относительно требуемых.
      , propsO  :: Set Prop -- Множество добавляемых свойств.
      , propsO' :: Set Prop -- Множество удаляемых свойств.
      }

    update :: State -> OutCont -> State
    update s c =
      State { attrs = attrs'
            , props = propsO c `Set.union' (props s \\ propsO' c) }
      where
        attrs' = case attrsO c of
          AddAttrs attrs' -> attrs' `Set.union' attrs s
          NewAttrs attrs' -> attrs'
\end{lstlisting}

Если если в операцию входят два потока, то чтобы посчитать состояние выхода, состояния входных потоков объединяются:

\begin{lstlisting}
    union :: State -> State -> State
    union s1 s2 = State { attrs = attrs s1 `Set.union` attrs s2
                        , props = props s1 `Set.union` props s2 }
\end{lstlisting}

Cостояние ребра, выходящего из источника совпадают с выходным контрактом этого источника. Если состояние входящих рёбер удовлетворяет входным контрактам операции, то состояние выходящих вычисляется обновлением состояния входа в соответствии с выходным контрактом.

Таким образом, мы умеем для конкретного графа вычислять состояния всех его рёбер и проверять контракты всех его нод.


\subsection{Верификация}

Заметим, что предложенная система контрактов является также и средством верификации вычислительных графов, подобным логике Хоара, предназначенной для доказательства корректности императивных компьютерных программ. В логике Хоара задаются так называемые тройки Хоара~--- предусловие, команда и постусловие. Программа считается корректной, если удовлетворяются предусловия и постусловия \cite{hoare}.
