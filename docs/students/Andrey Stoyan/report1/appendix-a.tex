\section*{Приложение А: развитие идеи}
\addcontentsline{toc}{section}{Приложение А: развитие идеи}

Первоначальной идеей была следующая: задавать множество конкретных графов, решающих данную задачу как пару из типа требуемого результата вычислений и контекста.
\textbf{Контекст}~--- это набор типизированных функций (операций) и констант (потоков).

Тогда каждый конкретный граф задавался бы термом, имеющим тип результата в данном контексте.
Имея алгоритм, перебирающий такие термы, мы бы получали множество конкретных графов, решающих поставленную задачу.
При наличии функции оценки эффективности конкретного графа, можно было бы выбрать из множества самый эффективный.

При разработке этой идеи возникало множество проблем.

\textbf{Задача населения типа (inhabitation problem)}~--- существует ли терм, имеющий заданный тип в данном контексте.

Оказывается, что задача населения разрешима только для довольно простых систем типов (например, $\lambda_\rightarrow$ или $\lambda\cap$). Если задача населения неразрешима, то заведомо не существует завершающегося алгоритма перебора. Таким образом, наиболее подходящие системы типов, с row polimorphism, нам не подходят \cite{rowpoly}.

Для оптимизации хотелось бы генерировать как можно больше различных графов, решающих одну и ту же задачу. Но оказывается, что простые системы типов просто не обеспечивают нужной гибкости. Например, есть только один способ расположить операции с типами $A \rightarrow B \text{ и } B \rightarrow C$. Чтобы их можно было переставлять местами, они должны быть эндоморфизмами: $A \rightarrow A \text{ и } A \rightarrow A$, но тогда у нас нет инструментов, чтобы гибко ограничивать перестановочность. $\lambda\cap$ предоставляет некоторые дополнительные возможности, но их тоже не достаточно.

Таким образом, только с помощью типов не получается добиться нужной гибкости с сохранением возможности ограничивать перестановочность.
Закономерно возникает идея расширить типы с помощью refinement types, вроде того, как сделано в Liquid Haskell \cite{liquidhaskell}.
Но при попытке добиться больших возможностей в ограничении перестановочности с помощью аннотирования типов предикатами, оказывается, что предикаты начинают нести всю выразительную нагрузку, и в типах отпадает смысл.

Идея с refinement types помогла оторваться от типов и подумать более широко.
Типы, аннотации к типам~--- это всё способы выразить контракт функции, перенести его проверку на этап компиляции.

Таким образом, на самом деле задача стоит в построении конкретных графов по набору операций, аннотированных контрактами. Идея с типами оказалась одним из потенциальных подходов к решению настоящей задачи.

Понятие контракта в свою очередь позволяет решать задачу в терминах предметной области, начиная с размышлений о том, что такое контракт операции в вычислительном графе.
То есть изначальный ход рассуждений вёл от частного к общему, от способа выражать контракты к самим контрактам, которые на самом деле всецело обуславливаются предметной областью. Это не могло привести к положительному результату.
