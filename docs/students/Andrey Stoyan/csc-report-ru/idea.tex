\section{Идея}

Вершины вычислительных графов могут быть трёх типов: \textbf{источники}, операции (\textbf{трансформации}) и \textbf{стоки} (data sinks). Источники не получают данных, только отдают. Трансформации принимают один или несколько потоков данных и порождают поток данных или несколько. Стоки не отдают данные другим операциям и стокам своего графа, а формируют результаты работы графа (как записи в базе данных, как новый поток для другой системы, и т.д.).

Будем называть \textbf{нодами} вершины всех типов.

Чтобы иметь возможность изменять форму графа, для каждой операции необходимо иметь информацию о требованиях, которые она выдвигает к данным, поступающим её на вход, и гарантии, которые она выставляет для производимых ею данных.

Такие требования и гарантии назовём \textbf{контрактами} операции, \textbf{входными} и \textbf{выходными} соответственно.

Далее будут приводиться листинги на языке Haskell, формализующие вводимые понятия.

\begin{lstlisting}
    -- InCont - входной контракт.
    -- OutCont - выходной контракт.
    -- Пока предположим, что трансформаций арности два будет достаточно.
    -- Будем считать, что стоки - это трансформации
    -- с определённым выходным контрактом.

    -- Вершины вычислительного графа, аннотированные контрактами
    data Node =
        Stream OutCont             -- Источник данных.
      | Tfm1 InCont OutCont        -- Трансформация арности один.
      | Tfm2 InCont InCont OutCont -- Трансформация арности два.
\end{lstlisting}

Зададим множество нод, аннотированных контрактами (\textbf{окружение}):
\begin{lstlisting}
    type Env = Map NodeName Node
\end{lstlisting}

Определим \textbf{семантику} вычислительного графа как подмножество множества нод, элементы которого формируют требуемые от графа результаты работы:
\begin{lstlisting}
    type Semantics = Set NodeName
\end{lstlisting}

Наконец, определим \textbf{кограф}, который перставляет собой пару из окружения и семантики:
\begin{lstlisting}
    type CoGraph = (Env, Semantics)
\end{lstlisting}

Пусть кограф задаёт множество \textbf{конкретных графов} (или просто \textbf{графов}) следующим образом:
граф задаётся данным кографом, если он состоит только из нод окружения, содержит каждую ноду семантики один раз, и контракты всех используемых нод удовлетворяются.

Будем использовать кографы в качестве нового способа задания вычислительных графов.
Каждый конкретный граф содержит все стоки, формирующие требуемый результат работы.
Все операции каждого графа получают валидные данные на вход и, следовательно, работают корректно.
Таким образом, все операции семантики так же работают корректно, и каждый граф, соответствующий данному кографу, выполняет одну и ту же, требуемую, работу.

Процесс от задания кографа до запуска задачи на целевом фраемворке выглядит следующим образом:
\begin{lstlisting}
    -- RGraph - конкретный граф в API целевого фраемворка.
    run :: CoGraph -> Runtime RGraph
    run = graphToRGraph . chooseGraph cost . genGraphs

    genGraphs :: CoGraph -> [Graph]
    cost :: Graph -> Integer
    chooseGraph :: (Graph -> Integer) -> [Graph] -> Graph
    graphToRGraph :: Graph -> Runtime RGraph
\end{lstlisting}


\subsection{Конкретные графы}

Будем представлять граф виде множества термов. Результат работы одной ноды может подаваться на вход нескольким нодам, поэтому в операциях будем хранить не сами подтермы, а ссылки на них.

\begin{lstlisting}
    data Term =
        Const NodeName
      | App1 NodeName TermRef
      | App2 NodeName TermRef TermRef

    type Graph = Map TermRef Term
\end{lstlisting}


\subsection{Контракты}

Будем считать, что данные имеют формат записей с именованными атрибутами.
Тогда, выделим два сорта информации о потоке данных: какие атрибуты имеют записи и какие существуют свойства атрибутов и связей между ними.

Введём состояние потока как совокупность информации о нём:
\begin{lstlisting}
    -- Атрибуты
    type Attr = AttrName

    -- Свойства
    type Prop = PropName

    data State = State
      { attrs :: Set Attr -- Множество атрибутов в потоке.
      , props :: Set Prop -- Множество свойств в потоке.
      }
\end{lstlisting}

Введём входной контракт и правило проверки:
\begin{lstlisting}
    data InCont = InCont
      { attrsI  :: Set Attr -- Множество требуемых атрибутов.
      , propsI  :: Set Prop -- Множество требуемых свойств.
      , propsI' :: Set Prop -- Множество запрещённых свойств.
      }

    match :: State -> InCont -> Bool
    match s c = attrsI c `Set.isSubsetOf` attrs s
             && propsI c `Set.isSubsetOf` props s
             && propsI' c `Set.disjoint`  props s
\end{lstlisting}

Пусть выходной контракт определяет разницу между состояниями входного и выходного потоков. Введём выходной контракт и правило обновления состояния:

\begin{lstlisting}
    data OutAttrs =
        AddAttrs (Set Attr) -- К множеству входящих атрибутов
                            -- добавятся новые из множества.
      | NewAttrs (Set Attr) -- Множество входящих атрибутов
                            -- заменится на новое.

    data OutCont = OutCont
      { attrsO  :: OutAttrs -- Изменения в составе атрибутов
                            -- относительно требуемых.
      , propsO  :: Set Prop -- Множество добавляемых свойств.
      , propsO' :: Set Prop -- Множество удаляемых свойств.
      }

    update :: State -> OutCont -> State
    update s c =
      State { attrs = attrs'
            , props = propsO c <> (props s \\ propsO' c) }
      where
        attrs' = case attrsO c of
          AddAttrs attrs' -> attrs' <> attrs s
          NewAttrs attrs' -> attrs'
\end{lstlisting}

Если если в операцию входят два потока, то чтобы посчитать состояние выхода, состояния входных потоков объединяются:

\begin{lstlisting}
    union :: State -> State -> State
    union s1 s2 = State { attrs = attrs s1 `Set.union` attrs s2
                        , props = props s1 `Set.union` props s2 }
\end{lstlisting}

Покажем, что мы можем определить состояние потока для всех рёбер конкретного графа. Действительно, состояние рёбер, выходящих из источников совпадают с их выходными контрактами. Если состояние входящих рёбер удовлетворяет входнымым контрактам операции, то состояние выходящих вычисляется обновлением состояния входа в соответствии с выходным контрактом.

Таким образом, мы умеем для конкретного графа вычислять состояния всех его рёбер и проверять контракты всех его нод.

\subsection{Пример}

TODO

% Пусть имеем следующие источники:

% Пусть мы имеем источник породами собак, источник с собаками, источник с людьми и источник с отношением дружбы между человеком и собакой.

% Требуется:
% \begin{itemize}
%     \item Вычислить статистику встречаемости кличек среди всех собак.
%     \item Вычислить зависимость между именем человека и породой собак, с которыми он дружит. Щенков не учитываем, с ними дружат все.
% \end{itemize}

% Запишем семантику:
% \begin{lstlisting}
%     dogsSemantics :: Semantics
%     dogsSemantics = semantics
%       [ -- Статистика кличек по всем собакам.
%         "petNamesStats"
%         -- Считает зависимость между именем человека
%         -- и кличкой его собаки.
%       , "nameBreedDep"
%       ]
% \end{lstlisting}

% Смотря на задачу, можно составить список трансформаций, которые понадобятся для решения задачи:
% \begin{itemize}
%     \item Фильтр щенков.
%     \item Join людей с отношением дружбы.
%     \item Join собак с отношением дружбы.
%     \item Join собак с породами.
% \end{itemize}

% Зададим контракты некоторых нод:
% \begin{lstlisting}
%     cograph :: CoGraph
%     cograph = (, petsSemantics) $ env
%       [ "pets" `ap0` outCont -- Атрибуты потока питомцев.
%                             ["pet.id", "pet.name", "pet.age", "pet.  breedId"]
%                             []
%                             []

%       , "petNamesStats" `ap1` inCont ["pet.name"]
%                                      []
%                                      -- Запрещаем свойства фильтраций,
%                                      -- чтобы учесть всех питомцев.
%                                      ["sameAge", "ageLT2020"]
%                               -- Обнуляются атрибуты, эта операция -   сток
%                          ->  outContN [] [] []

%       , "filterLT2020" `ap1` inCont ["pet.age"] [] []
%                         ->  outCont []
%                                      -- Добавляется свойство ограничения
%                                      -- возраста.
%                                      ["ageLT2020"]
%                                      []

%       -- Операция принимает два потока и делает реляционный join по
%       -- идентификатору человека.
%       , "joinPersonsFriends" `ap2` inCont ["person.id"] [] []
%                             <&>  inCont ["personId"] [] []
%                             ->  outCont [] [] []

%       , ...
%       ]
% \end{lstlisting}
