\section{Идея}

Вершины вычислительных графов могут быть трёх типов: \textbf{источники}, операции (\textbf{трансформации}) и \textbf{стоки} (data sinks). Источники не получают данных, только отдают. Трансформации принимают один или несколько потоков данных и порождают поток данных или несколько. Стоки не отдают данные другим операциям и стокам своего графа, а формируют результаты работы графа.

Будем называть \textbf{нодами} вершины всех типов.

Чтобы иметь возможность изменять форму графа, для каждой операции необходимо иметь информацию о требованиях, которые она выдвигает к данным, поступающим её на вход, и гарантии, которые она выставляет для производимых ею данных.

Такие требования и гарантии назовём \textbf{контрактами} операции, \textbf{входными} и \textbf{выходными} соответственно.

Далее будут приводиться листинги на языке Haskell, формализующие вводимые понятия.
Используемые конструкции языка объясняются в приложении. % TODO ref

\begin{lstlisting}
    -- InCont - входной контракт.
    -- OutCont - выходной контракт.
    -- Пока предположим, что трансформаций арности два будет достаточно.
    -- Будем считать, что стоки - это трансформации
    -- с определённым выходным контрактом.

    -- Вершины вычислительного графа, аннотированные контрактами
    data Node =
        Stream OutCont             -- Источник данных.
      | Tfm1 InCont OutCont        -- Трансформация арности один.
      | Tfm2 InCont InCont OutCont -- Трансформация арности два.
\end{lstlisting}

Зададим множество нод, аннотированных контрактами (\textbf{окружение}):
\begin{lstlisting}
    type Env = Map NodeName Node
\end{lstlisting}

Определим \textbf{семантику} вычислительного графа как подмножество множества нод, элементы которого формируют требуемые от графа результаты работы:
\begin{lstlisting}
    type Semantics = Set NodeName
\end{lstlisting}

Наконец, определим \textbf{кограф}, который перставляет собой пару из окружения и семантики:
\begin{lstlisting}
    type CoGraph = (Env, Semantics)
\end{lstlisting}

Пусть кограф задаёт множество \textbf{конкретных графов} (или просто \textbf{графов}) следующим образом:
граф задаётся данным кографом, если он состоит только из нод окружения и содержит каждую ноду семантики один раз.

Будем использовать кографы в качестве нового способа задания вычислительных графов.
Каждый конкретный граф содержит все стоки, формирующие требуемый результат работы.
Все операции каждого графа получают валидные данные на вход и, следовательно, работают корректно.
Таким образом, все операции семантики так же работают корректно, и каждый граф, соответствующий данному кографу, выполняет одну и ту же, требуемую, работу.

\subsection{Конкретные графы}

Будем представлять граф виде множества термов. Результат работы одной ноды может подаваться на вход нескольким нодам, поэтому в операциях будем хранить не сами подтермы, а ссылки на них.

\begin{lstlisting}
    data Term =
        Const NodeName
      | App1 NodeName TermRef
      | App2 NodeName TermRef TermRef

    type Graph = Map TermRef Term
\end{lstlisting}

\subsection{Контракты}

Будем считать, что данные имеют формат записей с именованными атрибутами.
Тогда, выделим два сорта информации о потоке данных: какие атрибуты имеют записи и какие существуют свойства атрибутов и связей между ними.

\begin{lstlisting}
    -- Атрибуты
    type Attr = AttrName

    -- Свойства
    type Prop = PropName

    -- Определим входной контракт:
    data InCont = InCont
      { attrsI  :: Set Attr -- Множество требуемых атрибутов
      , propsI  :: Set Prop -- Множество требуемых свойств
      , propsI' :: Set Prop -- Множество запрещённых свойств
      }

    -- Выходные атрибуты
    data OutAttrs =
        AddAttrs (Set Attr) -- К множеству входящих атрибутов
                            -- добавятся новые из множества.
      | NewAttrs (Set Attr) -- Множество входящих атрибутов
                            -- заменится на новое.

    -- Определим выходной контракт
    data OutCont = OutCont
      { attrsO  :: OutAttrs -- Изменения в составе атрибутов
                            -- относительно требуемых.
      , propsO  :: Set Prop -- Множество добавляемых свойств к требуемым.
      , propsO' :: Set Prop -- Множество удаляемых свойств из требуемых.
      }

    -- Определим состояние потока
    data State = State
      { attrs :: Set Attr -- Множество атрибутов в потоке.
      , props :: Set Prop -- Множество свойств в потоке.
      }
\end{lstlisting}

Таким образом, мы можем определить состояние потока для всех рёбер конкретного графа. Действительно, состояние рёбер, выходящих из источников~--- это копия полей их выходного контракта. Если состояние входящих рёбер удовлетворяет входному контракту операции, то состояние выходящих вычисляется применением выходного контракта к состоянию входа.

Если если в операцию входят два потока, то чтобы посчитать состояние выхода, состояния входных потоков объединяются:

\begin{lstlisting}
    union :: State -> State -> State
    union s1 s2 = State { attrs = attrs s1 `Set.union` attrs s2
                        , props = props s1 `Set.union` props s2 }
\end{lstlisting}

Ещё требуются две функции: проверки входного контракта и обновление состояние с помощью выходного контракта.

\begin{lstlisting}
    match :: State -> InCont -> Bool
    match s c = attrsI c `Set.isSubsetOf` attrs s
             && propsI c `Set.isSubsetOf` props s
             && propsI' c `Set.disjoint`  props s

    update :: State -> OutCont -> State
    update s c =
      State { attrs = attrs'
            , props = propsO c <> (props s \\ propsO' c) }
      where
        attrs' = case attrsO c of
          AddAttrs attrs' -> attrs' <> attrs s
          NewAttrs attrs' -> attrs'
\end{lstlisting}

\subsection{Пример}

TODO примеры в терминах контрактов, получающиеся и не получающиеся графы из такого описания
