\section{Идея}

Вершины вычислительных графов могут быть трёх типов: \textbf{источники}, операции (\textbf{трансформации}) и \textbf{стоки} (data sinks). Источники не получают данных, только отдают. Трансформации принимают один или несколько потоков данных и порождают поток данных или несколько. Стоки не отдают данные другим операциям и стокам своего графа, а формируют результаты работы графа.

Будем называть \textbf{нодами} вершины всех типов.

Чтобы иметь возможность изменять форму графа, для каждой операции необходимо иметь информацию о требованиях, которые она выдвигает к данным, поступающим её на вход, и гарантии, которые она выставляет для производимых ею данных.

Такие требования и гарантии назовём \textbf{контрактами} операции, \textbf{входными} и \textbf{выходными} соответственно.

Далее будут приводиться листинги на языке Haskell, формализующие вводимые понятия.
Используемые конструкции языка объясняются в приложении. % TODO ref

\begin{lstlisting}
    -- InCont - входной контракт.
    -- OutCont - выходной контракт.
    -- Пока предположим, что трансформаций арности два будет достаточно.
    -- Будем считать, что стоки - это трансформации
    -- с определённым выходным контрактом.

    -- Вершины вычислительного графа, аннотированные контрактами.
    data Node =
        Stream OutCont             -- Источник данных.
      | Tfm1 InCont OutCont        -- Трансформация арности один.
      | Tfm2 InCont InCont OutCont -- Трансформация арности два.
\end{lstlisting}

Зададим множество нод, аннотированных контрактами (\textbf{окружение}):
\begin{lstlisting}
    type Env = Map NodeName Node
\end{lstlisting}

Определим \textbf{семантику} вычислительного графа как подмножество множества нод, элементы которого формируют требуемые от графа результаты работы:
\begin{lstlisting}
    type Semantics = Set NodeName
\end{lstlisting}

Наконец, определим \textbf{кограф}, который перставляет собой пару из окружения и семантики:
\begin{lstlisting}
    type CoGraph = (Env, Semantics)
\end{lstlisting}

Пусть кограф задаёт множество \textbf{конкретных графов} (или просто \textbf{графов}) следующим образом:
граф задаётся данным кографом, если он состоит только из нод окружения и содержит каждую ноду семантики один раз.

Будем использовать кографы в качестве нового способа задания вычислительных графов.
Каждый конкретный граф содержит все стоки, формирующие требуемый результат работы.
Все операции каждого графа получают валидные данные на вход и, следовательно, работают корректно.
Таким образом, все операции семантики так же работают корректно, и каждый граф, соответствующий данному кографу, выполняет одну и ту же, требуемую, работу.

\subsection{Конкретные графы}

Будем представлять граф виде множества термов. Результат работы одной ноды может подаваться на вход нескольким нодам, поэтому в операциях будем хранить не сами подтермы, а ссылки на них.

\begin{lstlisting}
    data Term =
        Const NodeName
      | App1 NodeName TermRef
      | App2 NodeName TermRef TermRef

    type Graph = Map TermRef Term
\end{lstlisting}

\subsection{Контракты}

TODO Контракты

\subsection{Примеры}

TODO примеры в терминах контрактов, получающиеся и не получающиеся графы из такого описания
