# calco

CALculations by COntracts. Контрактное программирование как способ задания и оптимизации вычислительных графов распределённых потоковых систем.


## Существующие способы задания вычислительных графов

Современные фраемворки предоставляют два основных способа задания графов: композиция примитивных операций (Maps, Reduces...) и SQL запросы.

![flink's](https://flink.apache.org/img/api-stack.png)

### Недостатки

#### Композиция

В такой нотации нет информации о возможности переставлять между собой операции, из-за чего невозможно получить несколько вариантов графа, из которых можно было бы выбрать оптимальный.

#### Streaming SQL

В рамках одного запроса SQL позволяет генерировать множество планов исполнения, используя средства реляционной алгебры. Но чтобы записать комплексный граф, приходится использовать подзапросы (`SELECT ... FROM (SELECT ...) ...`), которые являются барьером для оптимизаций.


## Проблема

![photo_2020-12-03_16-57-25](https://user-images.githubusercontent.com/25281147/101049464-9a97be80-3594-11eb-85b3-5947cae5b72c.jpg)

Представим следующую ситуацию. У нас на кластере запущен сложный граф, показанный на рисунке.
Допустим, что нам нужно добавить на кластер ещё задачу, но значительная её часть уже вычисляется в работающем графе.
Таким образом, нам нужно взять этот очень комплексный граф и смержить в него граф новой задачи.

Производить модификации такого графа, чтобы максимально его зайдействовать в новой задаче, достаточно сложно. Ещё сложнее в процессе мержа производить ручные оптимизации, которые бы минимизировали, например, решардирования.


## Идея

Зададим множество функций, аннотированных контрактами.

Контракт функции представляет собой набор требований ко входным данным и набор гарантий, которые функция выставляет для результата своей работы.

Функция арности ноль является константой и соответствует потоку. Остальные функции соответствуют непрерывным непересекающимся фрагментам вычислительного графа, могут иметь состояние и побочные эффекты.

```haskell
-- Tfm = Transform
-- InCont = Input contract
-- OutCont = Output contract

type Streams = Map StreamName OutCont
type Tfms1 = Map TfmName (InCont, OutCont)
type Tfms2 = Map TfmName (InCont, InCont, OutCont)

-- Множество функций арностей 0, 1, 2, аннотированных контрактами
data Env = Env
  { streams :: Streams
  , tfms1 :: Tfms1
  , tfms2 :: Tfms2
  }
```

Назовём порядок функций топологией графа (или конкретным графом), а побочные эффекты, которые он производит в качестве результата своей работы, - семантикой.

Заметим, что в конкретном графе должны по одному разу быть использованы все функции, производящие требуемые побочные эффекты, чтобы он обладал данной семантикой.
Поэтому помимо набора функций, аннотированных контрактами, требуется задавать подмножество имён функций, которые производят результирующие побочные эффекты.

```haskell
type Semantics = Set TfmName
```

Выразим топологию графа в термах.

Результат одной операции может подаваться как вход в несколько других. Поэтому необходимо в терме содержать не сами подтермы, а ссылки на них (маркеры термов).

Также, конкретный граф не обязан иметь только один сток, в то время как каждый терм имеет только одну внешнюю функцию.

Таким образом, конкретный граф может быть представлен как отображение маркеров на термы.
Это представление можно конвертировать в запись топологии графа на API целевого фраемворка.

```haskell
type TermMarker = Integer

data Term = Const StreamName
          | App1 TfmName TermMarker
          | App2 TfmName TermMarker TermMarker

newtype Graph = Graph (Map TermMarker Term)
```

Вернёмся к проблеме. Добавим в множество функций новые, участвующие в решении новой задачи.
Ожидается, что это сделать проще, чем модифицировать конкретный комплексный граф.

По набору функций, аннотированных контрактами, сгенерируем множество конкретных графов, имеющих заданную семантику, и удовлетворяющих контрактам.
Из полученного множества выберем конкретный граф, самый оптимальный с точки зрения некоторой функции оценки.

Сложность в том, чтобы достаточно эффективно перебирать все множества термов (задающие конкретные графы), которые проходят проверку контрактов.
Для достижения этого возможно удасться использовать какой-то из следующих способов:
- Выразить контракты в некоторой системе типов и свести задачу к задаче перебора правильно типизируемых термов.
- Выразить контракты в системе типов, в которой не только верные с точки зрения контрактов термы будут правильно типизироваться. Тогда после того, как отработает алгоритм перебора термов, нужно будет провести фильтрацию, проверяя контракты.
- Свести контракты к формализмам темпоральной логики и использовать алгоритмы перебора случаев, используемые в верификаторах.

### Вид реализации и целевой API

Реализация должна быть представлена в виде библиотеки, которая по набору операций и потоков, аннотированных контрактами, и семантике, строит все конкретные графы с данной семантикой, удовлетворяющие контрактам, выбирает из них самый оптимальный в соответствии с некоторой кост-моделью, по которому строит вычислительный граф в целевом API.

```haskell
mkGraph :: (Env, Semantics) -> Beam BeamGraph
mkGraph = graphToBeam . chooseGraph cost . genGraphs

genGraphs :: (Env, Semantics) -> [Graph]
cost :: Graph -> Integer
chooseGraph :: (Graph -> Integer) -> [Graph] -> Graph
graphToBeam :: Graph -> Beam BeamGraph
```

Поскольку должна быть возможность переставлять операции, целевое API должно быть к языку программирования с динамической типизацией.

Возьмём Apache Beam API for Python:
- Язык с динамической типизацией.
- Позволяет абстрагироваться от конкретного рантайма (Apache Flink, Apache Spark, ...).

### Контракты

Введём два сорта контрактов: на входные данные и на результат:

```haskell
-- Атрибуты
data Attr = Attr StreamName AttrName

-- Свойства конкретных атрибутов и общие (связи между атрибутами)
data Prop = Prop PropName | AttrProp Attr PropName

-- Входной контракт
data InCont = InCont
  { attrsI :: Set Attr  -- Требуемые атрибуты
  , propsI :: Set Prop  -- Требуемые свойства
  , propsI' :: Set Prop -- Запрещённые свойства
  }

-- Проекция: уделение конкретных атрибутов или всех
data DelAttrs = DelAllAttrs | DelAttrs (Set Attr)

-- Контракт результата
data OutCont = OutCont
  { attrsO :: Set Attr  -- Добавляемые атрибуты
  , attrsO' :: DelAttrs -- Удаляемые атрибуты
  , propsO :: Set Prop  -- Добавляемые свойства
  , propsO' :: Set Prop -- Удаляемые свойства
  }
```

Поскольку Apache Beam API for Python выбрано целевым, достаточно научиться записывать контракты для каждой из ключевых операций:
- ParDo
- GroupBy
- CoGroupBy
- Combine
- Flatten
- Partition

#### ParDo

Обрабатывает отдельно каждый элемент потока (возможно, используя изменяемое состояние).

Может использоваться следующим образом:
- Может фильтровать поток. Тогда у потока обновляются свойства.
- Форматировать/обрабатывать поток. Добавляются свойства, что элементы прошли определённую обработку. Могут добавляться новые атрибуты.
- Делать проекции. Тогда указываются удаляемые атрибуты.

#### GroupBy

Группирует элементы с одинаковыми ключами.

Добавляет свойство сгруппированности по атрибуту.

TODO

#### CoGroupBy

Производит реляционный join двух потоков.

TODO

#### Combine

Считает величину по потоку. Возвращает проекцию на новое поле (посчитанную статистику).

#### Flatten

Объединяет потоки одного типа. Не будем рассматривать эту операцию. Её можно сделать в момент создания потока и присвоить обычный выходной контракт.

#### Partition

Разделяет поток на несколько. Редкая операция для ручных оптимизаций, не будем её рассматривать.


## Пример

### Требования к примеру

- Наличие всех базовых операций Apache Beam
- Наличие всех кейсов для оптимизации

### Граф

TODO

### Оптимизированный граф

TODO


## Генерация конкретных графов

TODO

<!-- ### Подход к реализации

Чем лучше выбранная система типов отражает контракты, тем больше возможностей переставлять операции и получать новые термы, но тем менее вероятно, что удасться найти алгоритм, который эффективно будет перебирать термы, адекватные задаче.

Таким образом, будем пробовать разные подходы к типизации и исследовать:
- Возможность получения различных термов по типовой записи
- Эффективность алгоритма населения -->


## Функция оценки

- Фильтры
- Решардирования

TODO


## Прототип на хаскеле

В данном репозатории присутствует прототип на хаскеле, отражающий способы работы с контрактами:
- Проверка
- TODO генерация графов
- TODO функция оценки


## Боевая реализация на питоне

TODO
