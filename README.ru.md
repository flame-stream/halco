# calco

CALculations by COntracts.

Контрактное программирование как способ задания и оптимизации вычислительных графов для распределённых потоковых систем.

- **calcohs** - прототип/формализация на Haskell
- **calco** - библиотека расширяющая Apache Beam Python API ц-графами


## Проблема

Современные фраемворки предоставляют два основных способа задания графов: композиция примитивных операций (*Map*, *Reduce* и т.д.) и SQL запросы (диалект Streaming SQL, для потоковой обработки).

![api-stack](https://flink.apache.org/img/api-stack.png)

Пусть мы хотим записать граф, схематично изображенный на рисунке:

![complex-graph](https://user-images.githubusercontent.com/25281147/101049464-9a97be80-3594-11eb-85b3-5947cae5b72c.jpg)

Когда мы составляем граф как композицию операций,
мы однозначно определяем их порядок и не предоставляем фраемворку информации о том,
какие операции с какими можно переставлять в целях оптимизации, оставляя пайплайн корректным.
Таким образом, возможна только ручная оптимизация.

Диалект Streaming SQL позволяет использовать в SQL запросах неограниченные источники данных.
Как и в случае с традиционным SQL, он предназначен для выборки данных из источников и подсчёта статистик, а не для записи комплексной бизнес-логики.

Пусть мы уже имеем написанный и работающий на кластере граф.
Попробуем добавить этому графу ещё одну функциональность и вернуть на кластер.
Постараемся максимально использовать промежуточные значения, вычисленные в исходном графе, чтобы не производить лишних повторных вычислений.

Сейчас для таких модификаций требуется вручную исправлять граф, производить оптимизации (минимизировать количество решардирований, размещать фильтрации как можно ближе к источникам данных и т.д.). В случае больших графов это довольно сложная работа, подверженная трудно уловимым ошибкам.

Таким образом, требуется разработать декларативный подход к описанию вычислительных графов, который бы упростил их задание и модификацию, и позволил бы производить автоматические оптимизации путём перестановки операций в графе.


## Идея

Вершины вычислительных графов могут быть трёх типов: **источники**, операции (**трансформации**) и **стоки** (data sinks). Источники не получают данных, только отдают. Трансформации принимают один или несколько потоков данных и порождают поток данных или несколько. Стоки не отдают данные другим операциям и стокам своего графа, только формируют результаты работы графа (как записи в базе данных, как новый поток для другой системы, и т.д.).

Будем называть **нодами** вершины всех типов.

Чтобы иметь возможность изменять форму графа, для каждой операции необходимо иметь информацию о требованиях, которые она выдвигает к данным, поступающим её на вход, и гарантии, которые она выставляет для производимых ею данных.

Такие требования и гарантии назовём **контрактами** операции, **входными** и **выходными** соответственно.

Далее будут приводиться листинги на языке Haskell, формализующие вводимые понятия.

```haskell
-- InCont - входной контракт.
-- OutCont - выходной контракт.
-- Пока предположим, что трансформаций арности два будет достаточно.
-- Будем считать, что стоки - это трансформации
-- с определённым выходным контрактом.

-- Вершины вычислительного графа, аннотированные контрактами
data Node =
    Stream OutCont             -- Источник данных.
  | Tfm1 InCont OutCont        -- Трансформация арности один.
  | Tfm2 InCont InCont OutCont -- Трансформация арности два.
```

Зададим множество нод, аннотированных контрактами (**окружение**):
```haskell
type Env = Map NodeName Node
```

Определим **семантику** вычислительного графа как подмножество множества нод, элементы которого формируют требуемые от графа результаты работы:
```haskell
type Semantics = Set NodeName
```

Наконец, определим **ц-граф**, который перставляет собой пару из окружения и семантики:
```haskell
type CGraph = (Env, Semantics)
```

Пусть ц-граф задаёт множество **конкретных графов** (или просто **графов**) следующим образом:
граф задаётся данным ц-графом, если он состоит только из нод окружения, содержит каждую ноду семантики один раз, и контракты всех используемых нод удовлетворяются.

Будем использовать ц-графы в качестве нового способа задания вычислительных графов.
Каждый конкретный граф содержит все стоки, формирующие требуемый результат работы.
Все операции каждого графа получают валидные данные на вход и, следовательно, работают корректно.
Таким образом, все операции семантики так же работают корректно, и каждый граф, соответствующий данному ц-графу, выполняет одну и ту же, требуемую, работу.

Процесс от задания ц-графа до запуска задачи на целевом фраемворке выглядит следующим образом:
```haskell
-- RGraph - конкретный граф в API целевого фраемворка.
run :: CGraph -> Runtime RGraph
run = graphToRGraph . chooseGraph cost . genGraphs

genGraphs :: CGraph -> [Graph]
cost :: Graph -> Integer
chooseGraph :: (Graph -> Integer) -> [Graph] -> Graph
graphToRGraph :: Graph -> Runtime RGraph
```

### Конкретные графы

Будем представлять граф виде множества термов. Результат работы одной ноды может подаваться на вход нескольким нодам, поэтому в операциях будем хранить не сами подтермы, а ссылки на них (маркеры).

```haskell
data Term =
    Const NodeName
  | App1 NodeName TermMarker
  | App2 NodeName TermMarker TermMarker

type Graph = Map TermRef Term
```

### Контракты

Будем считать, что данные имеют формат записей с именованными атрибутами.
Тогда, выделим два сорта информации о потоке данных: какие атрибуты имеют записи и какие существуют свойства атрибутов и связей между ними.

Введём состояние потока как совокупность информации о нём:
```haskell
-- Атрибуты
type Attr = AttrName

-- Свойства
type Prop = PropName

data State = State
  { attrs :: Set Attr -- Множество атрибутов в потоке.
  , props :: Set Prop -- Множество свойств в потоке.
  }
```

Введём входной контракт и правило проверки:
```haskell
data InCont = InCont
  { attrsI  :: Set Attr -- Множество требуемых атрибутов.
  , propsI  :: Set Prop -- Множество требуемых свойств.
  , propsI' :: Set Prop -- Множество запрещённых свойств.
  }

match :: State -> InCont -> Bool
match s c = attrsI c `Set.isSubsetOf` attrs s
         && propsI c `Set.isSubsetOf` props s
         && propsI' c `Set.disjoint`  props s
```

Пусть выходной контракт определяет разницу между состояниями входного и выходного потоков. Введём выходной контракт и правило обновления состояния:

```haskell
data OutAttrs =
    AddAttrs (Set Attr) -- К множеству входящих атрибутов
                        -- добавятся новые из множества.
  | NewAttrs (Set Attr) -- Множество входящих атрибутов
                        -- заменится на новое.

data OutCont = OutCont
  { attrsO  :: OutAttrs -- Изменения в составе атрибутов
                        -- относительно требуемых.
  , propsO  :: Set Prop -- Множество добавляемых свойств.
  , propsO' :: Set Prop -- Множество удаляемых свойств.
  }

update :: State -> OutCont -> State
update s c =
  State { attrs = attrs'
        , props = propsO c <> (props s \\ propsO' c) }
  where
    attrs' = case attrsO c of
      AddAttrs attrs' -> attrs' <> attrs s
      NewAttrs attrs' -> attrs'
```

Если если в операцию входят два потока, то чтобы посчитать состояние выхода, состояния входных потоков объединяются:

```haskell
union :: State -> State -> State
union s1 s2 = State { attrs = attrs s1 `Set.union` attrs s2
                    , props = props s1 `Set.union` props s2 }
```

Покажем, что мы можем определить состояние потока для всех рёбер конкретного графа. Действительно, состояние рёбер, выходящих из источников совпадают с их выходными контрактами. Если состояние входящих рёбер удовлетворяет входнымым контрактам операции, то состояние выходящих вычисляется обновлением состояния входа в соответствии с выходным контрактом.

Таким образом, мы умеем для конкретного графа вычислять состояния всех его рёбер и проверять контракты всех его нод.

## calco API example

TODO

```python
cograph, node = calco.cgraph(
    semantics={"write_word_count"}
)


@node
def lines() -> OutCont({"line"}):
    throw NotImplementedError()


@node
def split(...) -> ...:
    throw NotImplementedError()


@node
def count_words(...) -> ...
    throw NotImplementedError()


@node
def write_word_count(stats: InCont(attrs={"word", "count"})):
    throw NotImplementedError()
```
